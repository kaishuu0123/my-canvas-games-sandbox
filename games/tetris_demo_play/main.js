/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/games/tetris_demo_play/main.js":
/*!********************************************!*\
  !*** ./src/games/tetris_demo_play/main.js ***!
  \********************************************/
/***/ (() => {

eval("Array.prototype.shuffle = function(){\n\to = this;\n    for(var j, x, i = o.length; i; j = Math.floor(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);\n    return o;\n};\nfunction random(min, max, step){\n\tif(max === undefined){\n\t\tmax = min;\n\t\tmin = 0;\n\t}\n\tif(step === undefined)step = 1;\n\treturn Math.round(Math.random()*(max-min))+min;\n}\nfunction coin(){\n\treturn random(1) === 0;\n}\nfunction findFallSpeed(level){\n\treturn 60-(level-1)*8\n}\nfunction findGoal(level){\n\treturn 4*level;\n}\nfunction makeGarbage(map){\n\tmap.shift();\n\tvar garbage = [];\n\tfor(var i = 0; i < mapWidth; i ++)garbage.push(8);\n\tgarbage[random(garbage.length-1)] = 0;\n\tmap.push(garbage);\n}\nfunction opponent(player){\n\tif(player.name === 'player1')return p2;\n\tif(player.name === 'player2')return p1;\n}\n\nfunction Player(id, playing, testing){\n\tif(playing === undefined)playing = false;\n\tif(testing === undefined)testing = false;\n\tthis.score = 0;\n\tthis.displayScore = 0;\n\tthis.level = defaults.level;\n\tthis.lines = 0;\n\tthis.goal = findGoal(this.level);\n\tthis.map = [];\n\tthis.bag = [];\n\tthis.bag.list = [];\n\tthis.bag.initialized = false;\n\tthis.held = undefined;\n\tthis.canHold = true;\n\tthis.name = 'player'+id;\n\tthis.playing = playing;\n\tthis.testing = testing;\n\tthis.wins = 0;\n\tthis.blink = true;\n\tthis.blinkTimer = 0;\n\tthis.blinkLimit = 30;\n\tthis.garbage = 0;\n\tthis.startGarbage = 4;\n\tthis.ai = true;\n\tthis.dead = false;\n\tthis.deadTimer = 0;\n\tthis.deadLimit = 0;\n\tthis.idle = false;\n\tthis.idleTimer = 0;\n\tthis.idleLimit = 60;\n\tfor(var i = 0; i < mapHeight; i ++){\n\t\tthis.map.push([]);\n\t\tfor(var j = 0; j < mapWidth; j ++){\n\t\t\tthis.map[i][j] = 0;\n\t\t}\n\t}\n\tfor(var i = 0; i < this.startGarbage; i ++)makeGarbage(this.map);\n\tthis.killTile = function(){\n\t\tvar x;\n\t\tvar y;\n\t\tvar clear = true;\n\t\tfor(var i = 0; i < mapHeight; i ++){\n\t\t\tfor(var j = 0; j < mapWidth; j ++){\n\t\t\t\tif(this.map[i][j] !== 0)clear = false;\n\t\t\t}\n\t\t}\n\t\tif(clear){\n\t\t\tthis.dead = false;\n\t\t\tthis.idle = true;\n\t\t\treturn;\n\t\t}\n\t\tdo {\n\t\t\tx = random(0, mapWidth-1);\n\t\t\ty = random(0, mapHeight-1);\n\t\t} while(this.map[y][x] === 0);\n\t\tthis.map[y][x] = 0;\n\t\tif(this.name === 'player1')new Sprite(blockDestruction, (x-5)*blockSize, (y+6)*blockSize, blockSize, blockSize);\n\t\tif(this.name === 'player2')new Sprite(blockDestruction, (x+15)*blockSize, (y+6)*blockSize, blockSize, blockSize);\n\t\tdisplay.flip();\n\t}\n\tthis.reset = function(){\n\t\tfor(var i = 0; i < mapHeight; i ++){\n\t\t\tfor(var j = 0; j < mapWidth; j ++){\n\t\t\t\tthis.map[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tthis.idle = false;\n\t\tthis.dead = false;\n\t\tthis.held = undefined;\n\t\tthis.fallDelayMax = findFallSpeed(this.level);\n\t\tthis.garbage = 0;\n\t\tthis.score = 0;\n\t\tthis.displayScore = 0;\n\t\tthis.level = defaults.level;\n\t\tthis.lines = 0;\n\t\tthis.goal  = findGoal(this.level);\n\t\tfor(var i = 0; i < this.startGarbage; i ++)makeGarbage(this.map);\n\t\tbag.init(this);\n\t\tbag.draw(this);\n\t\twasDown['left'] = false;\n\t\twasDown['right']= false;\n\t\twasDown['up']   = false;\n\t\twasDown['down'] = false;\n\t\twasDown['w'] = false;\n\t\twasDown['a']= false;\n\t\twasDown['s']   = false;\n\t\twasDown['d'] = false;\n\t\twasDown['space'] = false;\n\t\twasDown['enter'] = false;\n\t\tthis.canHold = true;\n\t\tdisplay.flip();\n\t}\n\tthis.update = function(){\n\t\tthis.blinkTimer ++;\n\t\tif(this.blinkTimer >= this.blinkLimit){\n\t\t\tif(this.blink)this.blink = false;\n\t\t\telse this.blink = true;\n\t\t\tdisplay.flip();\n\t\t\tthis.blinkTimer = 0;\n\t\t}\n\t\tif(this.playing){\n\t\t\tif(this.idle){\n\t\t\t\tthis.idleTimer ++;\n\t\t\t\tif(this.idleTimer >= this.idleLimit){\n\t\t\t\t\tthis.idleTimer = 0;\n\t\t\t\t\tthis.idle = false;\n\t\t\t\t\tif(!this.ai)this.playing = false;\n\t\t\t\t\telse this.reset();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(this.dead){\n\t\t\t\tthis.deadTimer ++;\n\t\t\t\tif(this.deadTimer >= this.deadLimit){\n\t\t\t\t\tthis.deadTimer = 0;\n\t\t\t\t\tthis.killTile();\n\t\t\t\t\tthis.killTile();\n\t\t\t\t\tthis.killTile();\n\t\t\t\t\tthis.killTile();\n\t\t\t\t\tthis.killTile();\n\t\t\t\t\tthis.killTile();\n\t\t\t\t\tthis.killTile();\n\t\t\t\t\tthis.killTile();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!this.dead && !this.idle){\n\t\t\t\tif(this.shape.ai){\n\t\t\t\t\tthis.shape.aiTimer ++;\n\t\t\t\t\tif(this.shape.aiTimer >= this.shape.aiLimit){\n\t\t\t\t\t\tthis.shape.aiTimer = 0;\n\t\t\t\t\t\tthis.shape.aiLimit = 0;\n\t\t\t\t\t\t//this.shape.aiLimit = random(5, 25);\n\t\t\t\t\t\tthis.shape.goBestMove();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(this.shape.locking){\n\t\t\t\t\tthis.shape.lockDelay --;\n\t\t\t\t\tif(this.shape.lockDelay < 0){\n\t\t\t\t\t\tthis.shape.lockDelay = this.shape.lockDelayMax;\n\t\t\t\t\t\tthis.shape.lock();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.shape.fallDelay --;\n\t\t\t\tif(this.shape.fallDelay < 0){\n\t\t\t\t\tthis.shape.fallDelay = this.shape.fallDelayMax;\n\t\t\t\t\tthis.shape.move(0, 1);\n\t\t\t\t}\n\t\t\t\tvar beforeScore = Math.round(this.displayScore);\n\t\t\t\tthis.displayScore += (this.score-this.displayScore)/1;\n\t\t\t\tvar afterScore = Math.round(this.displayScore);\n\t\t\t\tif(beforeScore != afterScore)display.flip();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvar mapWidth  = 10;\nvar mapHeight = 22;\nvar frameRate = 100/6;\nvar defaults = {};\ndefaults.level = 1;\ndefaults.lockDelay = 10;\nvar p1 = new Player(1, true);\nvar p2 = new Player(2, true);\n\nvar sprites = [];\nvar paused = false;\nfunction oob(x, y, map, top){\n\tif(top === undefined)top = false;\n\tif(!top)return x < 0 || x > map[0].length-1 || y < 0 || y > map.length-1;\n\treturn x < 0 || x > map[0].length-1 || y > map.length-1;\n}\nvar display = {};\ndisplay.width  = 32;\ndisplay.height = 30;\ndisplay.flip = function(){\n\tctx.fillStyle = 'black';\n\tctx.fill();\n\tfor(var i = 1; i < display.height-9; i ++){\n\t\tfor(var j = 0; j < display.width; j ++){\n\t\t\tctx.drawImage(bg, j*blockSize, i*blockSize, blockSize, blockSize);\n\t\t}\n\t}\n\tvar gridOffsetX = 0;\n\tvar gridOffsetY = 1;\n\tvar x;\n\tvar y;\n\tfor(var i = 0; i < display.height; i ++){\n\t\tgridY = i+gridOffsetY;\n\t\tif(gridY < mapHeight){\n\t\t\tfor(var j = 0; j < display.width; j ++){\n\t\t\t\tgridX = j+gridOffsetX;\n\t\t\t\tif(gridX < mapWidth){\n\t\t\t\t\tx = blockSize\n\t\t\t\t\ty = blockSize*6;\n\t\t\t\t\tif(p1.playing){\n\t\t\t\t\t\tk = p1.map[gridY][gridX];\n\t\t\t\t\t\tif(paused)k = 0;\n\t\t\t\t\t\tif(k > 0 && !p1.dead && !p1.idle){\n\t\t\t\t\t\t\tfor(var l = 0; l < p1.shape.destinations.length; l ++){\n\t\t\t\t\t\t\t\tvar t = p1.shape.destinations[l];\n\t\t\t\t\t\t\t\tif(gridX === t.x && gridY === t.y){\n\t\t\t\t\t\t\t\t\tctx.drawImage(blockDestination, t.x*blockSize+x, t.y*blockSize+y, blockSize, blockSize);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdrawBlock(gridX*blockSize+x, gridY*blockSize+y, k);\n\t\t\t\t\t\tif(k == 0 && !paused && !p1.dead && !p1.idle){\n\t\t\t\t\t\t\tfor(var l = 0; l < p1.shape.destinations.length; l ++){\n\t\t\t\t\t\t\t\tvar t = p1.shape.destinations[l];\n\t\t\t\t\t\t\t\tif(gridX === t.x && gridY === t.y){\n\t\t\t\t\t\t\t\t\tctx.drawImage(blockDestination, t.x*blockSize+x, t.y*blockSize+y, blockSize, blockSize);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tdrawBlock(gridX*blockSize+x, gridY*blockSize+y, k);\n\t\t\t\t\t}\n\t\t\t\t\tx = blockSize*21\n\t\t\t\t\ty = blockSize*6;\n\t\t\t\t\tif(p2.playing){\n\t\t\t\t\t\tif(p2.shape != undefined){\n\t\t\t\t\t\t\tk = p2.map[gridY][gridX];\n\t\t\t\t\t\t\tif(paused)k = 0;\n\t\t\t\t\t\t\tif(k > 0 && !p2.dead && !p2.idle){\n\t\t\t\t\t\t\t\tfor(var l = 0; l < p2.shape.destinations.length; l ++){\n\t\t\t\t\t\t\t\t\tvar t = p2.shape.destinations[l];\n\t\t\t\t\t\t\t\t\tif(gridX === t.x && gridY === t.y){\n\t\t\t\t\t\t\t\t\t\tctx.drawImage(blockDestination, t.x*blockSize+x, t.y*blockSize+y, blockSize, blockSize);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdrawBlock(gridX*blockSize+x, gridY*blockSize+y, k);\n\t\t\t\t\t\t\tif(k == 0 && !paused && !p2.dead && !p2.idle){\n\t\t\t\t\t\t\t\tfor(var l = 0; l < p2.shape.destinations.length; l ++){\n\t\t\t\t\t\t\t\t\tvar t = p2.shape.destinations[l];\n\t\t\t\t\t\t\t\t\tif(gridX === t.x && gridY === t.y){\n\t\t\t\t\t\t\t\t\t\tctx.drawImage(blockDestination, t.x*blockSize+x, t.y*blockSize+y, blockSize, blockSize);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t\tdrawBlock(gridX*blockSize+x, gridY*blockSize+y, k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tctx.drawImage(matrix, 0, blockSize*6, (mapWidth+2)*blockSize, (mapHeight+gridOffsetY)*blockSize);\n\tctx.drawImage(matrix, blockSize*20, blockSize*6, (mapWidth+2)*blockSize, (mapHeight+gridOffsetY)*blockSize);\n\tx = (mapWidth+2)*blockSize;\n\n\tdrawString(208, 352, 'WINS');\n\tdrawString(208, 400, 'LEVEL');\n\tdrawString(208, 448, 'GOAL');\n\n\tctx.drawImage(box, 0, 0, 96, 96);\n\tctx.drawImage(box, blockSize*6, 0, 96, 96);\n\tif(p1.playing && p1.bag.initialized)drawBlockSample(blockSize, blockSize, p1.bag.next);\n\tif(p1.held !== undefined){\n\t\tdrawBlockSample(blockSize*7, blockSize, p1.held);\n\t}\n\tdrawString(blockSize, blockSize, 'NEXT');\n\tdrawString(blockSize*7, blockSize, 'HOLD');\n\tdrawNumber(blockSize, 464, Math.round(p1.displayScore), 8);\n\tdrawNumber(208, 368, p1.wins, 2);\n\tdrawNumber(208, 416, p1.level, 2);\n\tdrawNumber(208, 464, p1.goal-p1.lines, 2);\n\n\n\tctx.drawImage(box, (display.width-6)*blockSize, 0, 96, 96);\n\tctx.drawImage(box, (display.width-12)*blockSize, 0, 96, 96);\n\tif(p2.playing && p2.bag.initialized)drawBlockSample((display.width-5)*blockSize, blockSize, p2.bag.next);\n\tif(p2.held !== undefined){\n\t\tdrawBlockSample((display.width-11)*blockSize, blockSize, p2.held);\n\t}\n\tdrawString((display.width-5)*blockSize, blockSize, 'NEXT');\n\tdrawString((display.width-11)*blockSize, blockSize, 'HOLD');\n\tdrawNumber((display.width-9)*blockSize, 464, Math.round(p2.displayScore), 8);\n\tdrawNumber(272, 368, p2.wins, 2);\n\tdrawNumber(272, 416, p2.level, 2);\n\tdrawNumber(272, 464, p2.goal-p2.lines, 2);\n\n\tif(!paused){\n\t\tfor(var i = 0; i < sprites.length; i ++){\n\t\t\tvar t = sprites[i];\n\t\t\tctx.drawImage(t.sheet, t.spriteX, t.spriteY, t.width, t.height, t.x+6*blockSize, t.y, t.width, t.height);\n\t\t}\n\t} else {\n\t\tdrawString(blockSize*3, blockSize*17, 'PAUSED');\n\t\tdrawString(blockSize*23, blockSize*17, 'PAUSED');\n\t}\n\tif(p1.ai)drawString(blockSize*4, blockSize*10, 'DEMO');\n\tif((p1.ai || !p1.playing) && p1.blink && !paused){\n\t\tdrawString(blockSize, blockSize*17, 'PUSH SPACE');\n\t}\n\tif(p2.ai)drawString(blockSize*24, blockSize*10, 'DEMO');\n\tif((p2.ai || !p2.playing) && p2.blink && !paused){\n\t\tdrawString(blockSize*21, blockSize*17, 'PUSH ENTER');\n\t}\n\tif((p1.dead || p1.idle) && !p1.ai)drawString(blockSize, blockSize*17, 'GAME OVER!');\n\tif((p2.dead || p2.idle) && !p2.ai)drawString(blockSize*21, blockSize*17, 'GAME OVER!');\n\tdrawString(blockSize*13, 0, 'TETRIS');\n}\n\nvar blockIndex = 1;\nvar blockSize = 16;\n\nvar blockDestruction = new Image();\nblockDestruction.src = '/games/tetris_demo_play/images/destruction.png';\nvar blockDestination = new Image();\nblockDestination.src = '/games/tetris_demo_play/images/destination.png';\n\nvar blockSamples = new Image();\nblockSamples.src = '/games/tetris_demo_play/images/samples.png';\nvar blockSamplesCoords = {\n\t'I':{x:0,  y:0, width:4, height:4},\n\t'O':{x:4,  y:0, width:4, height:4},\n\t'J':{x:8,  y:0, width:4, height:4},\n\t'L':{x:12, y:0, width:4, height:4},\n\t'Z':{x:16, y:0, width:4, height:4},\n\t'T':{x:20, y:0, width:4, height:4},\n\t'S':{x:24, y:0, width:4, height:4},\n}\nfunction drawBlockSample(x, y, name){\n\tctx.drawImage(\n\t\tblockSamples,\n\t\tblockSamplesCoords[name].x*blockSize,\n\t\tblockSamplesCoords[name].y*blockSize,\n\t\tblockSamplesCoords[name].width*blockSize,\n\t\tblockSamplesCoords[name].height*blockSize,\n\t\tx,\n\t\ty,\n\t\tblockSamplesCoords[name].width*blockSize,\n\t\tblockSamplesCoords[name].height*blockSize\n\t\t);\n}\n\nvar matrix = new Image();\nmatrix.src = '/games/tetris_demo_play/images/matrix.png';\n\nvar box = new Image();\nbox.src = '/games/tetris_demo_play/images/box.png';\n\nvar chars = new Image();\nchars.src = '/games/tetris_demo_play/images/chars.png';\nvar charsCoords = {};\nvar charsOrder = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ! ';\nvar x = 0;\nvar y = 0;\nvar charsWidth = 160;\nvar charsHeight= 72;\nfor(var i = 0; i < charsOrder.length; i ++){\n\tif(x > charsWidth/blockSize-1){\n\t\tx = 0;\n\t\ty ++;\n\t}\n\tvar c = charsOrder.charAt(i);\n\tcharsCoords[c] = {};\n\tcharsCoords[c].x = x;\n\tcharsCoords[c].y = y;\n\tx ++;\n}\nfunction drawString(x, y, string){\n\tfor(var i = 0; i < string.length; i ++){\n\t\tvar c = string.charAt(i);\n\t\tif(c != ' '){\n\t\t\tctx.drawImage(\n\t\t\t\tchars,\n\t\t\t\tcharsCoords[c].x*blockSize,\n\t\t\t\tcharsCoords[c].y*(blockSize+2),\n\t\t\t\tblockSize,\n\t\t\t\tblockSize,\n\t\t\t\tx+blockSize*i,\n\t\t\t\ty,\n\t\t\t\tblockSize,\n\t\t\t\tblockSize\n\t\t\t\t);\n\t\t}\n\t}\n}\nfunction drawNumber(x, y, number, place){\n\tstring = number.toString();\n\tif(string.length > place){\n\t\tstring = '';\n\t\tfor(var i = 0; i < place; i ++)string += '0';\n\t}\n\twhile(string.length < place)string = '0'+string;\n\tfor(var i = 0; i < string.length; i ++){\n\t\tvar c = string.charAt(i);\n\t\tctx.drawImage(chars, charsCoords[c].x*blockSize, charsCoords[c].y*(blockSize+2), blockSize, blockSize, x+blockSize*i, y, blockSize, blockSize)\n\t}\n}\n\nvar bg = new Image();\nbg.src = '/games/tetris_demo_play/images/bgblock.png';\n\nvar blocks = new Image();\nblocks.src = '/games/tetris_demo_play/images/blocks.png';\nfunction drawBlock(x, y, index){\n\tctx.drawImage(blocks, blockSize*index, 0, blockSize, blockSize, x, y, blockSize, blockSize)\n}\n\nvar canvas = document.getElementById('myCanvas');\ncanvas.id = 'canvas';\ncanvas.width = blockSize*display.width;\ncanvas.height = blockSize*display.height;\ndocument.body.appendChild(canvas);\n\nvar ctx = canvas.getContext('2d');\nctx.rect(0, 0, canvas.width, canvas.height);\n\nvar origin = {x:3, y:0};\n\nvar colors = {'red':1, 'orange':2, 'yellow':3, 'green':4, 'cyan':5, 'blue':6, 'purple':7};\nvar shapeNames = ['O', 'T', 'J', 'L', 'I', 'S', 'Z'];\nvar bag = {};\nbag.init = function(player){\n\tplayer.bag.initialized = true;\n\tplayer.bag.list = [];\n\tplayer.bag.list.length = 0;\n\tfor(var i = 0; i < shapeNames.length; i ++)player.bag.list.push(shapeNames[i]);\n\tplayer.bag.list.shuffle();\n\tfor(var i = 0; i < random(0, shapeNames.length-1); i ++)player.bag.list.shift();\n\tplayer.bag.next = player.bag.list[0];\n}\nbag.draw = function(player){\n\tnew Shape(player.bag.next, player);\n\tplayer.bag.list.shift();\n\tif(player.bag.list.length === 0){\n\t\tfor(var i = 0; i < shapeNames.length; i ++)player.bag.list.push(shapeNames[i]);\n\t\tplayer.bag.list.shuffle();\n\t}\n\tplayer.bag.next = player.bag.list[0];\n}\nvar shapes = {\n\t'O':{tiles:[[{x:1, y:0}, {x:2, y:0}, {x:1, y:1}, {x:2, y:1}]], color:'orange'},\n\t'T':{tiles:[\n\t\t[{x:1, y:0}, {x:0, y:1}, {x:1, y:1}, {x:2, y:1}],\n\t\t[{x:1, y:0}, {x:1, y:1}, {x:2, y:1}, {x:1, y:2}],\n\t\t[{x:0, y:1}, {x:1, y:1}, {x:2, y:1}, {x:1, y:2}],\n\t\t[{x:1, y:0}, {x:0, y:1}, {x:1, y:1}, {x:1, y:2}],\n\t\t], color:'blue'},\n\t'J':{tiles:[\n\t\t[{x:0, y:0}, {x:0, y:1}, {x:1, y:1}, {x:2, y:1}],\n\t\t[{x:1, y:0}, {x:2, y:0}, {x:1, y:1}, {x:1, y:2}],\n\t\t[{x:0, y:1}, {x:1, y:1}, {x:2, y:1}, {x:2, y:2}],\n\t\t[{x:1, y:0}, {x:1, y:1}, {x:0, y:2}, {x:1, y:2}],\n\t\t], color:'yellow'},\n\t'L':{tiles:[\n\t\t[{x:2, y:0}, {x:0, y:1}, {x:1, y:1}, {x:2, y:1}],\n\t\t[{x:1, y:0}, {x:1, y:1}, {x:1, y:2}, {x:2, y:2}],\n\t\t[{x:0, y:1}, {x:1, y:1}, {x:2, y:1}, {x:0, y:2}],\n\t\t[{x:0, y:0}, {x:1, y:0}, {x:1, y:1}, {x:1, y:2}],\n\t\t], color:'green'},\n\t'I':{tiles:[\n\t\t[{x:0, y:1}, {x:1, y:1}, {x:2, y:1}, {x:3, y:1}],\n\t\t[{x:2, y:0}, {x:2, y:1}, {x:2, y:2}, {x:2, y:3}],\n\t\t[{x:0, y:2}, {x:1, y:2}, {x:2, y:2}, {x:3, y:2}],\n\t\t[{x:1, y:0}, {x:1, y:1}, {x:1, y:2}, {x:1, y:3}],\n\t\t], color:'red'},\n\t'S':{tiles:[\n\t\t[{x:1, y:0}, {x:2, y:0}, {x:0, y:1}, {x:1, y:1}],\n\t\t[{x:1, y:0}, {x:1, y:1}, {x:2, y:1}, {x:2, y:2}],\n\t\t[{x:1, y:1}, {x:2, y:1}, {x:0, y:2}, {x:1, y:2}],\n\t\t[{x:0, y:0}, {x:0, y:1}, {x:1, y:1}, {x:1, y:2}],\n\t\t], color:'purple'},\n\t'Z':{tiles:[\n\t\t[{x:0, y:0}, {x:1, y:0}, {x:1, y:1}, {x:2, y:1}],\n\t\t[{x:2, y:0}, {x:1, y:1}, {x:2, y:1}, {x:1, y:2}],\n\t\t[{x:0, y:1}, {x:1, y:1}, {x:1, y:2}, {x:2, y:2}],\n\t\t[{x:1, y:0}, {x:0, y:1}, {x:1, y:1}, {x:0, y:2}],\n\t\t], color:'cyan'},\n};\nfunction Sprite(sheet, x, y, width, height, interval, loop){\n\tvar self = this;\n\tif(interval === undefined)interval = 'none';\n\tif(loop === undefined)loop = false;\n\tthis.x = x;\n\tthis.y = y;\n\tthis.spriteX = this.width*this.index;\n\tthis.spriteY = 0;\n\tthis.sheet = sheet;\n\tthis.width = width;\n\tthis.height= height;\n\tthis.index = 0;\n\tthis.frames = this.sheet.width/this.width;\n\tthis.loop  = loop;\n\tthis.kill = function(){\n\t\tfor(var i = 0; i < sprites.length; i ++){\n\t\t\tvar t = sprites[i];\n\t\t\tif(t.width === this.width && t.height === this.height && t.index === this.index && t.frames === this.frames){\n\t\t\t\tsprites.splice(i, 1);\n\t\t\t\tclearInterval(this.interval);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tthis.update = function(){\n\t\tthis.spriteX = this.width*this.index;\n\t\tthis.index ++;\n\t\tif(this.index == this.frames){\n\t\t\tif(loop)this.index = 0;\n\t\t\telse this.kill();\n\t\t}\n\t}\n\tsprites.push(this);\n\tthis.update();\n}\nfunction calculateScore(map){\n\tvar score = 0;\n\tvar aggregateHeight = 0;\n\tvar completeLines = 0;\n\tvar holes = 0;\n\tvar holeDepth = 0;\n\tvar bumpiness = 0;\n\tvar column = [];\n\tvar segments = [];\n\tvar tiles = [];\n\tvar chainMap = [];\n\tfor(var i = 0; i < mapHeight; i ++){\n\t\tchainMap.push([]);\n\t\tfor(var j = 0; j < mapWidth; j ++)chainMap[i].push({filled:false});\n\t}\n\tfor(var i = 0; i < mapHeight; i ++){\n\t\tfor(var j = 0; j < mapWidth; j ++){\n\t\t\tif(map[i][j] === 0)break;\n\t\t\tif(j === mapWidth-1){\n\t\t\t\tcompleteLines ++;\n\t\t\t\t// map.splice(i, 1);\n\t\t\t\t// var temp = [];\n\t\t\t\t// map.unshift(temp);\n\t\t\t\t// for(var k = 0; k < mapWidth; k ++)temp.push(0);\n\t\t\t}\n\t\t}\n\t}\n\tif(completeLines > 0){\n\t\tfor(var i = 0; i < mapHeight; i ++){\n\t\t\tfor(var j = 0; j < mapWidth; j ++){\n\t\t\t\tvar t;\n\t\t\t\tif(oob(j, i, map))t = 0;\n\t\t\t\telse t = map[i][j];\n\t\t\t\tif(t != 0 && !chainMap[i][j].filled){\n\t\t\t\t\tfloodFill(j, i, map, chainMap, tiles);\n\t\t\t\t\tsegments.push(tiles)\n\t\t\t\t\ttiles = [];\n\t\t\t\t\ttiles.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(var i = 0; i < segments.length; i ++){\n\t\t\tvar s = segments[i];\n\t\t\tfor(var j = 0; j < s.length; j ++){\n\t\t\t\tvar t = s[j];\n\t\t\t\tmap[t.y][t.x] = 0;\n\t\t\t}\n\t\t\tvar done = false;\n\t\t\tvar diters = 0;\n\t\t\twhile(!done){\n\t\t\t\tditers ++;\n\t\t\t\tfor(var j = 0; j < s.length; j ++){\n\t\t\t\t\tt = s[j];\n\t\t\t\t\tt.y ++;\n\t\t\t\t}\n\t\t\t\tfor(var j = 0; j < s.length; j ++){\n\t\t\t\t\tt = s[j];\n\t\t\t\t\tif(t.y > mapHeight-1 || map[t.y][t.x] != 0){\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(done){\n\t\t\t\t\tfor(var j = 0; j < s.length; j ++){\n\t\t\t\t\t\tt = s[j];\n\t\t\t\t\t\tt.y --;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(var j = 0; j < s.length; j ++){\n\t\t\t\tvar t = s[j];\n\t\t\t\tmap[t.y][t.x] = t.id;\n\t\t\t}\n\t\t}\n\t}\n\tfor(var j = 0; j < mapWidth; j ++){\n\t\tcolumn[j] = {};\n\t\tcolumn[j].height = 0;\n\t\tfor(var i = 0; i < mapHeight; i ++){\n\t\t\tif(map[i][j] > 0){\n\t\t\t\tcolumn[j].height = mapHeight-i;\n\t\t\t\taggregateHeight += column[j].height;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(var j = 1; j < mapWidth; j ++){\n\t\tbumpiness += Math.abs(column[j].height-column[j-1].height);\n\t}\n\tfor(var j = 0; j < mapWidth; j ++){\n\t\tcolumn[j].holes = 0;\n\t\tcolumn[j].holeDepth = 0;\n\t\tvar streak = 0;\n\t\tvar depth = 0;\n\t\tfor(var i = mapHeight-1; i >= 0; i --){\n\t\t\tif(map[i][j] > 0){\n\t\t\t\tcolumn[j].holes += streak;\n\t\t\t\tstreak = 0;\n\t\t\t} else {\n\t\t\t\tstreak ++;\n\t\t\t}\n\t\t}\n\t\tif(column[j].holes > 0){\n\t\t\tfor(var i = mapHeight-1; i >= 0; i --){\n\t\t\t\tif(map[i][j] == 0){\n\t\t\t\t\tcolumn[j].holeDepth = Math.abs(column[j].height-(mapHeight - 1 - i)-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tholes += column[j].holes;\n\t\tholeDepth += column[j].holeDepth;\n\t}\n\t//score = -0.66569*aggregateHeight + -0.46544*bumpiness + 0.99275*completeLines + -0.24077*holes;\n\tif(aggregateHeight >= mapHeight-4 || holes > 0)score = -aggregateHeight + -bumpiness + completeLines + -100000*holes;\n\telse score = -aggregateHeight + -bumpiness + 100*completeLines + -10000*holes;\n\tfor(var j = 0; j < mapWidth; j ++)if(map[0][j] > 0)score = -999999999;\n\treturn {total:score, aggregateHeight:aggregateHeight, bumpiness:bumpiness, completeLines:completeLines, holes:holes, holeDepth:holeDepth};\n}\nfunction floodFill(x, y, map, chainMap, tiles){\n\tchainMap[y][x].filled = true;\n\ttiles.push({x:x, y:y, id:map[y][x]});\n\tfor(var i = -1; i <= 1; i ++){\n\t\tvar ry = y+i;\n\t\tfor(var j = -1; j <= 1; j ++){\n\t\t\tvar rx = x+j;\n\t\t\tif(Math.abs(x-rx) + Math.abs(y-ry) === 1 && !oob(rx, ry, map) && map[ry][rx] !== 0 && !chainMap[ry][rx].filled){\n\t\t\t\tfloodFill(rx, ry, map, chainMap, tiles);\n\t\t\t}\n\t\t}\n\t}\n}\nfunction Shape(type, owner){\n\towner.shape = this;\n\tthis.x = origin.x;\n\tthis.y = origin.y;\n\tthis.width = 0;\n\tthis.height = 0;\n\tthis.type = type;\n\tthis.rotationIndex = 0;\n\tthis.initializing = true;\n\tthis.destinations = [];\n\tthis.segments = [];\n\tthis.tiles = [];\n\tthis.chainMap = [];\n\tthis.fallDelayMax = findFallSpeed(owner.level);\n\tthis.fallDelay = this.fallDelayMax;\n\tthis.lockDelayMax = defaults.lockDelay;\n\tthis.lockDelay = this.lockDelayMax;\n\tthis.locked = false;\n\tthis.locking = false;\n\tthis.o = opponent(owner);\n\tthis.ai = owner.ai;\n\tthis.aiTimer = 0;\n\tthis.aiLimit = 5;\n\tthis.aiRotates = 0;\n\tthis.aiRotatesMax = 4;\n\tthis.bestMove = undefined;\n\tthis.findBest = function(type, map, tetris, lookahead){\n\t\tif(lookahead === undefined)lookahead = false;\n\t\tthis.clear();\n\t\tvar moves = [];\n\t\tvar valid = false;\n\t\tvar startX = this.x;\n\t\tvar startY = this.y;\n\t\tvar tempMap = [];\n\t\tfor(var i = 0; i < mapHeight; i ++){\n\t\t\ttempMap.push([]);\n\t\t\tfor(var j = 0; j < mapWidth; j ++){\n\t\t\t\ttempMap[i].push(map[i][j]);\n\t\t\t}\n\t\t}\n\t\tvar beforeScore = calculateScore(tempMap);\n\t\tif(beforeScore.aggregateHeight > 7*mapWidth){\n\t\t\ttetris = false;\n\t\t\t//console.log('Stack is too tall; temporarily deactivating TETRIS mode')\n\t\t}\n\t\tif(beforeScore.holes > 0){\n\t\t\ttetris = false;\n\t\t\t//console.log('There are holes in the stack; temporarily deactivating TETRIS mode')\n\t\t}\n\t\tfor(var j = 0; j < shapes[type].tiles.length; j ++){\n\t\t\tthis.x = -2;\n\t\t\twhile(this.x < mapWidth){\n\t\t\t\tvar destinations = [];\n\t\t\t\tdestinations.length = 0;\n\t\t\t\tvalid = true;\n\t\t\t\tfor(var i = 0; i < shapes[type].tiles[j].length; i ++){\n\t\t\t\t\tvar t = shapes[type].tiles[j][i];\n\t\t\t\t\tvar x = t.x+this.x;\n\t\t\t\t\tvar y = t.y+this.y;\n\t\t\t\t\tif(oob(x, y, tempMap) || (tetris && x == mapWidth-1) || tempMap[y][x] > 0){\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(valid){\n\t\t\t\t\tvar airborne = true;\n\t\t\t\t\tvar tx = this.x;\n\t\t\t\t\tvar ty = this.y;\n\t\t\t\t\twhile(airborne){\n\t\t\t\t\t\tty += 1;\n\t\t\t\t\t\tfor(var i = 0; i < shapes[type].tiles[j].length; i ++){\n\t\t\t\t\t\t\tvar t = shapes[type].tiles[j][i];\n\t\t\t\t\t\t\tif(t.y+ty < 0)continue;\n\t\t\t\t\t\t\tif(t.y+ty > mapHeight-1 || tempMap[t.y+ty][t.x+tx] !== 0){\n\t\t\t\t\t\t\t\tairborne = false;\n\t\t\t\t\t\t\t\tty -= 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(var i = 0; i < shapes[type].tiles[j].length; i ++){\n\t\t\t\t\t\tvar t = shapes[type].tiles[j][i];\n\t\t\t\t\t\tvar x = t.x+tx;\n\t\t\t\t\t\tvar y = t.y+ty;\n\t\t\t\t\t\ttempMap[y][x] = colors[shapes[type].color];\n\t\t\t\t\t\tdestinations.push({x:x, y:y});\n\t\t\t\t\t}\n\t\t\t\t\tprospect = {spots:destinations, x:tx, y:ty, rotation:j, score:calculateScore(tempMap)};\n\t\t\t\t\tmoves.push(prospect);\n\t\t\t\t\tfor(var i = 0; i < destinations.length; i ++){\n\t\t\t\t\t\tvar t = destinations[i];\n\t\t\t\t\t\ttempMap[t.y][t.x] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.x ++;\n\t\t\t}\n\t\t}\n\t\tif(lookahead){\n\t\t\tfor(var i = 0; i < moves.length; i ++){\n\t\t\t\tvar m = moves[i];\n\t\t\t\tfor(var j = 0; j < m.spots; j ++){\n\t\t\t\t\tvar s = m.spots[j];\n\t\t\t\t\ttempMap[s.y][s.x] = 8;\n\t\t\t\t\tm.score += findBest(owner.bag.next, tempMap, tetris, false).score;\n\t\t\t\t\ttempMap[s.y][s.x] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar bestMove = {};\n\t\tvar scores = [];\n\t\tfor(var i = 0; i < moves.length; i ++){\n\t\t\tvar m = moves[i];\n\t\t\tvar score = m.score.total;\n\t\t\tscores.push(score);\n\t\t}\n\t\tscores.sort(function(a, b){return b-a});\n\t\tfor(var i = 0; i < moves.length; i ++){\n\t\t\tif(moves[i].score.total === scores[0])bestMove = {x:moves[i].x, y:moves[i].y, rotation:moves[i].rotation, score:moves[i].score};\n\t\t}\n\t\tthis.x = startX;\n\t\tthis.y = startY;\n\t\tthis.restore();\n\t\tif(bestMove.score.holes > beforeScore.holes && tetris){\n\t\t\t//console.log('Best move creates a hole; temporarily deactivating TETRIS mode.')\n\t\t\treturn this.findBest(type, map, false, lookahead)\n\t\t}\n\t\treturn bestMove;\n\t}\n\tthis.goBestMove = function(){\n\t\tvar moved = false;\n\t\tvar lookahead = owner.name === 'player1';\n\t\tif(this.bestMove === undefined){\n\t\t\tthis.bestMove = this.findBest(this.type, owner.map, true, lookahead);\n\t\t}\n\t\tif(!owner.testing){\n\t\t\tif(this.rotationIndex != this.bestMove.rotation){\n\t\t\t\tthis.rotate(1);\n\t\t\t\tmoved = true;\n\t\t\t}\n\t\t\tif(this.x < this.bestMove.x)moved = this.move( 1, 0);\n\t\t\telse\n\t\t\tif(this.x > this.bestMove.x)moved = this.move(-1, 0);\n\t\t\tif(this.x === this.bestMove.x && this.rotationIndex == this.bestMove.rotation){\n\t\t\t\tthis.dash( 0, 1);\n\t\t\t\tthis.lock();\n\t\t\t\tmoved = true;\n\t\t\t}\n\t\t\tif(!moved){\n\t\t\t\tif(this.aiRotates >= this.aiRotatesMax){\n\t\t\t\t\tthis.bestMove = undefined;\n\t\t\t\t} else {\n\t\t\t\t\tthis.rotate(1);\n\t\t\t\t\tthis.aiRotates ++;\n\t\t\t\t\t//console.log(\"Move blocked, rotating\")\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.clear();\n\t\t\tthis.x = this.bestMove.x;\n\t\t\tthis.rotationIndex = this.bestMove.rotation;\n\t\t\tthis.restore();\n\t\t\tthis.update();\n\t\t\tthis.dash( 0, 1);\n\t\t\tthis.lock();\n\t\t}\n\n\t}\n\tthis.check = function(){\n\t\t// for(var i = 0; i < shapes[this.type].tiles[this.rotationIndex].length; i ++){\n\t\t// \tvar t = shapes[this.type].tiles[this.rotationIndex][i];\n\t\t// \tvar x = t.x+this.x;\n\t\t// \tvar y = t.y+this.y;\n\t\t// \tif(oob(x, y, owner.map) || owner.map[y][x] > 0){\n\t\t// \t\tthis.lock();\n\t\t// \t}\n\t\t// }\n\t}\n\tthis.clear = function(){\n\t\tfor(var i = 0; i < shapes[this.type].tiles[this.rotationIndex].length; i ++){\n\t\t\tvar t = shapes[this.type].tiles[this.rotationIndex][i];\n\t\t\tvar x = t.x+this.x;\n\t\t\tvar y = t.y+this.y;\n\t\t\tif(!oob(x, y, owner.map)){\n\t\t\t\towner.map[y][x] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tthis.restore = function(){\n\t\tfor(var i = 0; i < shapes[this.type].tiles[this.rotationIndex].length; i ++){\n\t\t\tvar t = shapes[this.type].tiles[this.rotationIndex][i];\n\t\t\tvar x = t.x+this.x;\n\t\t\tvar y = t.y+this.y;\n\t\t\tif(!oob(x, y, owner.map)){\n\t\t\t\towner.map[y][x] = colors[shapes[this.type].color];\n\t\t\t}\n\t\t}\n\t}\n\tthis.update = function(){\n\t\tthis.clear();\n\t\tvar tx = this.x;\n\t\tvar ty = this.y;\n\t\tthis.destinations = [];\n\t\tthis.destinations.length = 0;\n\t\tvar valid = true;\n\t\twhile(valid){\n\t\t\tty += 1;\n\t\t\tfor(var i = 0; i < shapes[this.type].tiles[this.rotationIndex].length; i ++){\n\t\t\t\tvar t = shapes[this.type].tiles[this.rotationIndex][i];\n\t\t\t\tif(t.y+ty < 0)continue;\n\t\t\t\tif(t.y+ty > mapHeight-1 || owner.map[t.y+ty][t.x+tx] !== 0){\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tty -= 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(var i = 0; i < shapes[this.type].tiles[this.rotationIndex].length; i ++){\n\t\t\tvar t = shapes[this.type].tiles[this.rotationIndex][i];\n\t\t\tvar x = t.x+this.x;\n\t\t\tvar y = t.y+this.y;\n\t\t\tif(!oob(x, y, owner.map)){\n\t\t\t\towner.map[y][x] = colors[shapes[this.type].color];\n\t\t\t}\n\t\t\tthis.destinations.push({x:t.x+tx, y:t.y+ty});\n\t\t}\n\t\tthis.finalX = tx;\n\t\tthis.finalY = ty;\n\t\tdisplay.flip();\n\t}\n\tthis.hold = function(){\n\t\tif(owner.canHold){\n\t\t\tthis.lockDelay = this.lockDelayMax;\n\t\t\tfor(var i = 0; i < shapes[this.type].tiles[this.rotationIndex].length; i ++){\n\t\t\t\tvar t = shapes[this.type].tiles[this.rotationIndex][i];\n\t\t\t\tvar x = t.x+this.x;\n\t\t\t\tvar y = t.y+this.y;\n\t\t\t\tif(!oob(x, y, owner.map)){\n\t\t\t\t\towner.map[y][x] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(owner.held === undefined){\n\t\t\t\towner.held = this.type;\n\t\t\t\tbag.draw(owner);\n\t\t\t} else {\n\t\t\t\tnew Shape(owner.held, owner);\n\t\t\t\towner.held = this.type;\n\t\t\t}\n\t\t\towner.canHold = false;\n\t\t\tdisplay.flip();\n\t\t}\n\t}\n\tthis.size = function(){\n\t\tthis.width = 0;\n\t\tthis.height = 0;\n\t\tvar x1 = 0;\n\t\tvar x2 = 0;\n\t\tvar y1 = 0;\n\t\tvar y2 = 0;\n\t\tfor(var i = 0; i < shapes[this.type].tiles[this.rotationIndex].length; i ++){\n\t\t\tvar t = shapes[this.type].tiles[this.rotationIndex][i];\n\t\t\tif(t.x < x1)x1 = t.x;\n\t\t\tif(t.x > x2)x2 = t.x;\n\t\t\tif(t.y < y1)y1 = t.y;\n\t\t\tif(t.y > y2)y2 = t.y;\n\t\t}\n\t\tthis.width = Math.abs(x1-x2);\n\t\tthis.height = Math.abs(y1-y2);\n\t}\n\tthis.rotate = function(difference){\n\t\tif(difference === undefined)difference = 1;\n\t\tvar targetIndex = this.rotationIndex+difference;\n\t\tif(targetIndex >= shapes[this.type].tiles.length)targetIndex = 0;\n\t\tif(targetIndex < 0)targetIndex = shapes[this.type].tiles.length-1;\n\t\tfor(var i = 0; i < shapes[this.type].tiles[this.rotationIndex].length; i ++){\n\t\t\tvar t = shapes[this.type].tiles[this.rotationIndex][i];\n\t\t\tvar x = t.x+this.x;\n\t\t\tvar y = t.y+this.y;\n\t\t\tif(!oob(x, y, owner.map)){\n\t\t\t\towner.map[y][x] = 0;\n\t\t\t}\n\t\t}\n\t\tvar ox = 0;\n\t\tvar oy = 0;\n\t\tvar iters = 0;\n\t\tvar outside = true;\n\t\tvar valid = true;\n\t\twhile(outside){\n\t\t\toutside = false;\n\t\t\tfor(var i = 0; i < shapes[this.type].tiles[targetIndex].length; i ++){\n\t\t\t\tvar t = shapes[this.type].tiles[targetIndex][i];\n\t\t\t\tif(oob(t.x+this.x+ox, t.y+this.y+oy, owner.map) || (t.y+this.y+oy !== -1 && owner.map[t.y+this.y+oy][t.x+this.x+ox] !== 0)){\n\t\t\t\t\toutside = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!outside){\n\t\t\t\tvalid = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(iters === 0){\n\t\t\t\tox = 0;\n\t\t\t\toy = -1;\n\t\t\t}else\n\t\t\tif(iters === 1){\n\t\t\t\tox = 0;\n\t\t\t\toy = 1;\n\t\t\t}else\n\t\t\tif(iters === 2){\n\t\t\t\tox = -1;\n\t\t\t\toy = 0;\n\t\t\t}else\n\t\t\tif(iters === 3){\n\t\t\t\tox = 1;\n\t\t\t\toy = 0;\n\t\t\t}else\n\t\t\tif(iters === 4){\n\t\t\t\tox = -2;\n\t\t\t\toy = 0;\n\t\t\t}else\n\t\t\tif(iters === 5){\n\t\t\t\tox = 2;\n\t\t\t\toy = 0;\n\t\t\t}else{\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titers ++;\n\t\t}\n\t\tif(valid){\n\t\t\tthis.lockDelay = this.lockDelayMax;\n\t\t\tthis.locking = false;\n\t\t\tthis.x += ox;\n\t\t\tthis.y += oy;\n\t\t\tthis.rotationIndex = targetIndex;\n\t\t\tthis.size();\n\t\t}\n\t\tthis.update();\n\t\twasDown['up'] = false;\n\t\twasDown['w'] = false;\n\t}\n\tthis.dash = function(dx, dy){\n\t\tif(dx === 0 && dy > 0){\n\t\t\tfor(var i = 0; i < shapes[this.type].tiles[this.rotationIndex].length; i ++){\n\t\t\t\tvar t = shapes[this.type].tiles[this.rotationIndex][i];\n\t\t\t\tvar x = t.x+this.x;\n\t\t\t\tvar y = t.y+this.y;\n\t\t\t\tif(!oob(x, y, owner.map)){\n\t\t\t\t\towner.map[y][x] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\towner.score += Math.abs(this.y-this.finalY)*2;\n\t\t\tthis.x = this.finalX;\n\t\t\tthis.y = this.finalY;\n\t\t\tthis.update();\n\t\t} else {\n\t\t\twhile(true)if(!this.move(dx, dy))break;\n\t\t\tif(!this.locked)this.update();\n\t\t}\n\t}\n\tthis.move = function(dx, dy, points){\n\t\tif(points === undefined)points = 0;\n\t\tvar moved = false;\n\t\tif(this.locked){\n\t\t\treturn;\n\t\t}\n\t\tvar tx = this.x + dx;\n\t\tvar ty = this.y + dy;\n\t\tvar valid = true;\n\t\tthis.clear();\n\t\tfor(var i = 0; i < shapes[this.type].tiles[this.rotationIndex].length; i ++){\n\t\t\tvar t = shapes[this.type].tiles[this.rotationIndex][i];\n\t\t\tif(oob(t.x+tx, t.y+ty, owner.map, true) || (t.y+this.y !== -1 && owner.map[t.y+ty][t.x+tx] !== 0)){\n\t\t\t\tif(dy === 1 && (t.y+ty > mapHeight-1 || owner.map[t.y+ty][t.x+tx] !== 0)){\n\t\t\t\t\tthis.locking = true;\n\t\t\t\t\twasDown['down'] = false;\n\t\t\t\t\twasDown['s'] = false;\n\t\t\t\t}\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(valid){\n\t\t\tif(dx === 0 && dy === 1)owner.score += points;\n\t\t\tthis.x = tx;\n\t\t\tthis.y = ty;\n\t\t\tmoved = true;\n\t\t\tthis.lockDelay = this.lockDelayMax;\n\t\t\tthis.locking = false;\n\t\t\tthis.locked = false;\n\t\t}\n\t\tthis.update();\n\t\tif(!(dx === 0 && dy === 0))if(this.initializing)this.initializing = false;\n\t\treturn moved;\n\t}\n\tthis.lock = function(){\n\t\tthis.locked = true;\n\t\tthis.locking = false;\n\t\tvar gameOver = false;\n\t\tvar chain = 0;\n\t\tvar checking = true;\n\t\tvar iters = 0;\n\t\twhile(checking){\n\t\t\titers ++;\n\t\t\tchecking = false;\n\t\t\tfor(var i = 0; i < mapHeight; i ++){\n\t\t\t\tvar k = 0;\n\t\t\t\tfor(var j = 0; j < mapWidth; j ++){\n\t\t\t\t\tvar t;\n\t\t\t\t\tif(oob(j, i, owner.map))t = 0;\n\t\t\t\t\telse t = owner.map[i][j];\n\t\t\t\t\tif(t != 0){\n\t\t\t\t\t\tif(i === 0){\n\t\t\t\t\t\t\tgameOver = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(t != 0 && k === j)k ++;\n\t\t\t\t\telse k = 0;\n\t\t\t\t\tif(j === mapWidth-1 && k > 0){\n\t\t\t\t\t\tchain ++;\n\t\t\t\t\t\towner.goal --;\n\t\t\t\t\t\towner.map.splice(i, 1);\n\t\t\t\t\t\tvar temp = [];\n\t\t\t\t\t\towner.map.unshift(temp);\n\t\t\t\t\t\tfor(var l = 0; l < mapWidth; l ++){\n\t\t\t\t\t\t\ttemp.push(0);\n\t\t\t\t\t\t\tif(owner.name === 'player1')new Sprite(blockDestruction, (l-5)*blockSize, (i+6)*blockSize, blockSize, blockSize);\n\t\t\t\t\t\t\tif(owner.name === 'player2')new Sprite(blockDestruction, (l+15)*blockSize, (i+6)*blockSize, blockSize, blockSize);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchecking = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(chain > 0){\n\t\t\t\tthis.segments = [];\n\t\t\t\tthis.segments.length = 0;\n\t\t\t\tthis.tiles = [];\n\t\t\t\tthis.tiles.length = 0;\n\t\t\t\tthis.chainMap = [];\n\t\t\t\tthis.chainMap.length = 0;\n\t\t\t\tfor(var i = 0; i < mapHeight; i ++){\n\t\t\t\t\tthis.chainMap.push([]);\n\t\t\t\t\tfor(var j = 0; j < mapWidth; j ++)this.chainMap[i].push({filled:false});\n\t\t\t\t}\n\t\t\t\tfor(var i = 0; i < mapHeight; i ++){\n\t\t\t\t\tfor(var j = 0; j < mapWidth; j ++){\n\t\t\t\t\t\tvar t;\n\t\t\t\t\t\tif(oob(j, i, owner.map))t = 0;\n\t\t\t\t\t\telse t = owner.map[i][j];\n\t\t\t\t\t\tif(t != 0 && !this.chainMap[i][j].filled){\n\t\t\t\t\t\t\tfloodFill(j, i, owner.map, this.chainMap, this.tiles);\n\t\t\t\t\t\t\tthis.segments.push(this.tiles)\n\t\t\t\t\t\t\tthis.tiles = [];\n\t\t\t\t\t\t\tthis.tiles.length = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(var i = 0; i < this.segments.length; i ++){\n\t\t\t\t\tvar s = this.segments[i];\n\t\t\t\t\tfor(var j = 0; j < s.length; j ++){\n\t\t\t\t\t\tvar t = s[j];\n\t\t\t\t\t\towner.map[t.y][t.x] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tvar done = false;\n\t\t\t\t\tvar diters = 0;\n\t\t\t\t\twhile(!done){\n\t\t\t\t\t\tditers ++;\n\t\t\t\t\t\tfor(var j = 0; j < s.length; j ++){\n\t\t\t\t\t\t\tt = s[j];\n\t\t\t\t\t\t\tt.y ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(var j = 0; j < s.length; j ++){\n\t\t\t\t\t\t\tt = s[j];\n\t\t\t\t\t\t\tif(t.y > mapHeight-1 || owner.map[t.y][t.x] != 0){\n\t\t\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(done){\n\t\t\t\t\t\t\tfor(var j = 0; j < s.length; j ++){\n\t\t\t\t\t\t\t\tt = s[j];\n\t\t\t\t\t\t\t\tt.y --;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(var j = 0; j < s.length; j ++){\n\t\t\t\t\t\tvar t = s[j];\n\t\t\t\t\t\towner.map[t.y][t.x] = t.id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(gameOver){\n\t\t\tgameOver = false;\n\t\t\towner.dead = true;\n\t\t\tif(this.o.playing && !(this.o.ai && !owner.ai) && !(owner.ai && !this.o.ai)){\n\t\t\t\tthis.o.dead = true;\n\t\t\t\tthis.o.wins ++;\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\tif(chain === 1)owner.score += 100 * owner.level;\n\t\t\tif(chain === 2)owner.score += 300 * owner.level;\n\t\t\tif(chain === 3)owner.score += 500 * owner.level;\n\t\t\tif(chain === 4)owner.score += 800 * owner.level;\n\t\t\tif(chain >=  5)owner.score += 1000 * (chain-4) * owner.level;\n\t\t\tif(this.o.playing){\n\t\t\t\tif(chain >= 2){\n\t\t\t\t\tif((owner.ai && this.o.ai) || (!owner.ai && !this.o.ai)){\n\t\t\t\t\t\tthis.o.garbage += chain-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(owner.goal <= 0){\n\t\t\t\towner.goal = findGoal(owner.level) - owner.goal;\n\t\t\t\towner.level ++;\n\t\t\t\tthis.fallDelayMax = findFallSpeed(owner.level);\n\t\t\t}\n\t\t\twhile(owner.garbage > 0){\n\t\t\t\towner.garbage --;\n\t\t\t\tmakeGarbage(owner.map);\n\t\t\t}\n\t\t\tdisplay.flip();\n\t\t\towner.canHold = true;\n\t\t\tbag.draw(owner);\n\t\t\twasDown['left'] = false;\n\t\t\twasDown['right']= false;\n\t\t\twasDown['up']   = false;\n\t\t\twasDown['down'] = false;\n\t\t\twasDown['w'] = false;\n\t\t\twasDown['a']= false;\n\t\t\twasDown['s']   = false;\n\t\t\twasDown['d'] = false;\n\t\t}\n\t}\n\tthis.size();\n\tthis.check();\n\tthis.update();\n}\nkeyDown = {};\nkeyDown['left'] = false;\nkeyDown['right']= false;\nkeyDown['up']   = false;\nkeyDown['down'] = false;\nkeyDown['p'] \t= false;\nkeyDown['w'] \t= false;\nkeyDown['a']\t= false;\nkeyDown['s']   \t= false;\nkeyDown['q'] \t= false;\nkeyDown['\\''] \t= false;\nkeyDown['leftShift']= false;\nkeyDown['rightShift']= false;\nkeyDown['space']= false;\nkeyDown['enter']= false;\nwasDown = {};\nwasDown['left'] = false;\nwasDown['right']= false;\nwasDown['up']   = false;\nwasDown['down'] = false;\nwasDown['p'] \t= false;\nwasDown['w'] \t= false;\nwasDown['a']\t= false;\nwasDown['s']   \t= false;\nwasDown['d'] \t= false;\nwasDown['q'] \t= false;\nwasDown['\\''] \t= false;\nwasDown['leftShift']= false;\nwasDown['rightShift']= false;\nwasDown['space']= false;\nwasDown['enter']= false;\nfunction keydown(e){\n\tswitch(e.keyCode){\n\t\tcase 37:\n\t\t\tif(!wasDown['left'] && !keyDown['left'])wasDown['left'] = true;\n\t\t\tkeyDown['left'] = true;\n\t\t\tbreak;\n\t\tcase 39:\n\t\t\tif(!wasDown['right'] && !keyDown['right'])wasDown['right'] = true;\n\t\t\tkeyDown['right'] = true;\n\t\t\tbreak;\n\t\tcase 38:\n\t\t \tif(!wasDown['up'] && !keyDown['up'])wasDown['up'] = true;\n\t\t\tkeyDown['up'] = true;\n\t\t\tbreak;\n\t\tcase 40:\n\t\t\tif(!wasDown['down'] && !keyDown['down'])wasDown['down'] = true;\n\t\t\tkeyDown['down'] = true;\n\t\t\tbreak;\n\t\tcase 65:\n\t\t\tif(!wasDown['a'] && !keyDown['a'])wasDown['a'] = true;\n\t\t\tkeyDown['a'] = true;\n\t\t\tbreak;\n\t\tcase 68:\n\t\t\tif(!wasDown['d'] && !keyDown['d'])wasDown['d'] = true;\n\t\t\tkeyDown['d'] = true;\n\t\t\tbreak;\n\t\tcase 87:\n\t\t \tif(!wasDown['w'] && !keyDown['w'])wasDown['w'] = true;\n\t\t\tkeyDown['w'] = true;\n\t\t\tbreak;\n\t\tcase 83:\n\t\t\tif(!wasDown['s'] && !keyDown['s'])wasDown['s'] = true;\n\t\t\tkeyDown['s'] = true;\n\t\t\tbreak;\n\t\tcase 80:\n\t\t\tif(!wasDown['p'] && !keyDown['p'])wasDown['p'] = true;\n\t\t\tkeyDown['p'] = true;\n\t\t\tbreak;\n\t\tcase 81:\n\t\t\tif(!wasDown['q'] && !keyDown['q'])wasDown['q'] = true;\n\t\t\tkeyDown['q'] = true;\n\t\t\tbreak;\n\t\tcase 222:\n\t\t\tif(!wasDown['\\''] && !keyDown['\\''])wasDown['\\''] = true;\n\t\t\tkeyDown['\\''] = true;\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\tif(!wasDown['enter'] && !keyDown['enter'])wasDown['enter'] = true;\n\t\t\tkeyDown['enter'] = true;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tif (e.location === KeyboardEvent.DOM_KEY_LOCATION_LEFT){\n\t\t\t\tkeyDown['leftShift'] = true;\n\t\t\t} else if (e.location === KeyboardEvent.DOM_KEY_LOCATION_RIGHT){\n\t\t\t\tkeyDown['rightShift'] = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tif(!wasDown['space'] && !keyDown['space'])wasDown['space'] = true;\n\t\t\tkeyDown['space'] = true;\n\t\t\tbreak;\n\t}\n\tif(!paused){\n\t\tif(wasDown['space']){\n\t\t\tif(p1.ai){\n\t\t\t\tp1.ai = false;\n\t\t\t\tp1.reset();\n\t\t\t} else {\n\t\t\t\tp1.shape.dash( 0, 1);\n\t\t\t}\n\t\t\twasDown['space'] = false;\n\t\t}\n\t\tif(wasDown['enter']){\n\t\t\tif(p2.ai){\n\t\t\t\tp2.ai = false;\n\t\t\t\tp2.reset();\n\t\t\t} else {\n\t\t\t\tp2.shape.dash( 0, 1);\n\t\t\t}\n\t\t\twasDown['enter'] = false;\n\t\t}\n\t\tif(p1.playing && !p1.ai){\n\t\t\tif(wasDown['a'])p1.shape.move(-1, 0);\n\t\t\tif(wasDown['d'])p1.shape.move( 1, 0);\n\t\t\tif(wasDown['w'])p1.shape.rotate();\n\t\t\tif(wasDown['s']){\n\t\t\t\tif(p1.shape.locking)p1.shape.lock();\n\t\t\t\telse p1.shape.move( 0, 1);\n\t\t\t}\n\t\t\tif(keyDown['leftShift']){\n\t\t\t\tp1.shape.hold();\n\t\t\t}\n\t\t}\n\t\tif(p2.playing && !p2.ai){\n\t\t\tif(wasDown['left'])p2.shape.move(-1, 0);\n\t\t\tif(wasDown['right'])p2.shape.move( 1, 0);\n\t\t\tif(wasDown['up'])p2.shape.rotate();\n\t\t\tif(wasDown['down']){\n\t\t\t\tif(p2.shape.locking)p2.shape.lock();\n\t\t\t\telse p2.shape.move( 0, 1, 1);\n\t\t\t}\n\t\t\tif(keyDown['rightShift'])p2.shape.hold();\n\t\t}\n\t}\n\tif(wasDown['p']){\n\t\tif(!paused){\n\t\t\tpaused = true;\n\t\t} else {\n\t\t\tpaused = false;\n\t\t}\n\t\tdisplay.flip();\n\t\twasDown['p'] = false;\n\t}\n}\nfunction keyup(e){\n\tswitch(e.keyCode){\n\t\tcase 37:\n\t\t\tkeyDown['left'] = false;\n\t\t\twasDown['left'] = false;\n\t\t\tbreak;\n\t\tcase 39:\n\t\t\tkeyDown['right'] = false;\n\t\t\twasDown['right'] = false;\n\t\t\tbreak;\n\t\tcase 38:\n\t\t\tkeyDown['up'] = false;\n\t\t\twasDown['up'] = false;\n\t\t\tbreak;\n\t\tcase 40:\n\t\t\tkeyDown['down'] = false;\n\t\t\twasDown['down'] = false;\n\t\t\tbreak;\n\t\tcase 65:\n\t\t\tkeyDown['a'] = false;\n\t\t\twasDown['a'] = false;\n\t\t\tbreak;\n\t\tcase 68:\n\t\t\tkeyDown['d'] = false;\n\t\t\twasDown['d'] = false;\n\t\t\tbreak;\n\t\tcase 87:\n\t\t\tkeyDown['w'] = false;\n\t\t\twasDown['w'] = false;\n\t\t\tbreak;\n\t\tcase 83:\n\t\t\tkeyDown['s'] = false;\n\t\t\twasDown['s'] = false;\n\t\t\tbreak;\n\t\tcase 80:\n\t\t\tkeyDown['p'] = false;\n\t\t\twasDown['p'] = false;\n\t\t\tbreak;\n\t\tcase 81:\n\t\t\tkeyDown['q'] = false;\n\t\t\twasDown['q'] = false;\n\t\t\tbreak;\n\t\tcase 222:\n\t\t\tkeyDown['\\''] = false;\n\t\t\twasDown['\\''] = false;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tif(keyDown['leftShift'])keyDown['leftShift'] = false;\n\t\t\tif(keyDown['rightShift'])keyDown['rightShift'] = false;\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\tkeyDown['enter'] = false;\n\t\t\twasDown['enter'] = false;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tkeyDown['space'] = false;\n\t\t\twasDown['space'] = false;\n\t\t\tbreak;\n\t}\n}\nif(p1.playing){\n\tbag.init(p1);\n\tbag.draw(p1);\n}\nif(p2.playing){\n\tbag.init(p2);\n\tbag.draw(p2);\n}\ndocument.onkeydown = keydown;\ndocument.onkeyup   = keyup;\nfunction onEnterFrame(){\n\tif(!paused){\n\t\tp1.update();\n\t\tp2.update();\n\t}\n\tvar updated = false;\n\tfor(var i = 0; i < sprites.length; i ++){\n\t\tvar sprite = sprites[i];\n\t\tsprite.update();\n\t\tupdated = true;\n\t}\n\tif(updated)display.flip();\n}\nvar enterFrame = setInterval(onEnterFrame, frameRate);\n\n//# sourceURL=webpack://my-canvas-games-sandbox/./src/games/tetris_demo_play/main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/games/tetris_demo_play/main.js"]();
/******/ 	
/******/ })()
;