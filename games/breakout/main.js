/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/games/breakout/main.ts":
/*!************************************!*\
  !*** ./src/games/breakout/main.ts ***!
  \************************************/
/***/ (() => {

eval("\nvar main = function () {\n    var canvas = document.getElementById(\"myCanvas\");\n    var ctx = canvas.getContext(\"2d\");\n    if (ctx == null) {\n        console.log('Cannot find myCanvas.');\n        return;\n    }\n    var baseColor = \"#0095DD\";\n    var x = canvas.width / 2;\n    var y = canvas.height - 30;\n    var dx = 2;\n    var dy = -2;\n    var ballRadius = 10;\n    var paddleWidth = 75;\n    var paddleHeight = 10;\n    var paddleX = (canvas.width - paddleWidth) / 2;\n    var leftPressed = false;\n    var rightPressed = false;\n    var interval = null;\n    var brickRowCount = 3;\n    var brickColumnCount = 5;\n    var brickWidth = 75;\n    var brickHeight = 20;\n    var brickPadding = 10;\n    var brickOffsetTop = 30;\n    var brickOffsetLeft = 30;\n    var score = 0;\n    var lives = 3;\n    var mouseMoveHandler = function (e) {\n        var relativeX = e.clientX - canvas.offsetLeft;\n        if (relativeX > 0 && relativeX < canvas.width) {\n            paddleX = relativeX - paddleWidth / 2;\n        }\n    };\n    document.addEventListener(\"mousemove\", mouseMoveHandler, false);\n    var keyDownHandler = function (e) {\n        if (e.key === \"Right\" || e.key == \"ArrowRight\") {\n            rightPressed = true;\n        }\n        else if (e.key === \"Left\" || e.key == \"ArrowLeft\") {\n            leftPressed = true;\n        }\n    };\n    var keyUpHandler = function (e) {\n        if (e.key === \"Right\" || e.key == \"ArrowRight\") {\n            rightPressed = false;\n        }\n        else if (e.key === \"Left\" || e.key == \"ArrowLeft\") {\n            leftPressed = false;\n        }\n    };\n    document.addEventListener(\"keydown\", keyDownHandler, false);\n    document.addEventListener(\"keyup\", keyUpHandler, false);\n    var drawLives = function () {\n        ctx.font = \"16px Arial\";\n        ctx.fillStyle = baseColor;\n        ctx.fillText(\"Lives: \".concat(lives), canvas.width - 65, 20);\n    };\n    var drawScore = function () {\n        ctx.font = \"16px Arial\";\n        ctx.fillStyle = baseColor;\n        ctx.fillText(\"Score: \".concat(score), 8, 20);\n    };\n    var collisionDetection = function () {\n        for (var c = 0; c < brickColumnCount; c++) {\n            for (var r = 0; r < brickRowCount; r++) {\n                var b = bricks[c][r];\n                if (b.status === 1) {\n                    if (x > b.x &&\n                        x < b.x + brickWidth &&\n                        y > b.y &&\n                        y < b.y + brickHeight) {\n                        dy = -dy;\n                        b.status = 0;\n                        score++;\n                        if (score === brickRowCount * brickColumnCount) {\n                            alert(\"YOU WIN, CONGRATULATIONS!\");\n                            document.location.reload();\n                        }\n                    }\n                }\n            }\n        }\n    };\n    var bricks = [];\n    for (var c = 0; c < brickColumnCount; c++) {\n        bricks[c] = [];\n        for (var r = 0; r < brickRowCount; r++) {\n            bricks[c][r] = { x: 0, y: 0, status: 1 };\n        }\n    }\n    var drawBricks = function () {\n        for (var c = 0; c < brickColumnCount; c++) {\n            for (var r = 0; r < brickRowCount; r++) {\n                if (bricks[c][r].status == 1) {\n                    var brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;\n                    var brickY = r * (brickHeight + brickPadding) + brickOffsetTop;\n                    bricks[c][r].x = brickX;\n                    bricks[c][r].y = brickY;\n                    ctx.beginPath();\n                    ctx.rect(brickX, brickY, brickWidth, brickHeight);\n                    ctx.fillStyle = baseColor;\n                    ctx.fill();\n                    ctx.closePath();\n                }\n            }\n        }\n    };\n    var drawPaddle = function () {\n        ctx.beginPath();\n        ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);\n        ctx.fillStyle = baseColor;\n        ctx.fill();\n        ctx.closePath();\n        if (rightPressed) {\n            paddleX = Math.min(paddleX + 7, canvas.width - paddleWidth);\n        }\n        else if (leftPressed) {\n            paddleX = Math.max(paddleX - 7, 0);\n        }\n    };\n    var drawBall = function () {\n        ctx.beginPath();\n        ctx.arc(x, y, ballRadius, 0, Math.PI * 2);\n        ctx.fillStyle = baseColor;\n        ctx.fill();\n        ctx.closePath();\n    };\n    var draw = function () {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        drawBricks();\n        drawBall();\n        drawPaddle();\n        collisionDetection();\n        drawScore();\n        drawLives();\n        if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {\n            dx = -dx;\n        }\n        if (y + dy < ballRadius) {\n            dy = -dy;\n        }\n        else if (y + dy > canvas.height - ballRadius) {\n            if (x > paddleX && x < paddleX + paddleWidth) {\n                dy = -dy;\n            }\n            else {\n                lives--;\n                if (lives <= 0) {\n                    alert(\"GAME OVER\");\n                    document.location.reload();\n                }\n                else {\n                    x = canvas.width / 2;\n                    y = canvas.height - 30;\n                    dx = 2;\n                    dy = -2;\n                    paddleX = (canvas.width - paddleWidth) / 2;\n                }\n            }\n        }\n        x += dx;\n        y += dy;\n        requestAnimationFrame(draw);\n    };\n    draw();\n};\ndocument.addEventListener(\"DOMContentLoaded\", main);\n\n\n//# sourceURL=webpack://my-canvas-games-sandbox/./src/games/breakout/main.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/games/breakout/main.ts"]();
/******/ 	
/******/ })()
;